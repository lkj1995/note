### HTTP(超文本传输协议)
- 基于C/S模型(客户端/服务器)
- HTTPS
  - HTTP+SSL(安全套接字协议),SSL处于传输层之上,HTTP之下的协议,用于加密HTTP的数据
    - SSL协议可分为两层： 
      - SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 
      - SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。

![ssl_tls](.\img\ssl_tls.jpg)

- 应用层协议,可传输文本,图片,音频,视频(任意类型的数据对象)
- HTTP1.1 提出了持久连接的方法,减少重复建立连接的开销
- 无状态协议,即你进行的操作不会被记录,Cookie解决了此问题
- URI---URL(统一资源定位符)通过位置定位资源
- URN 通过名字定位资源
- 通用格式
  ```C
  <scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<frag>
  ```
  - 方案scheme:指定访问服务器获取资源时使用哪种协议，有 HTTP、 HTTPS、 FTP、SMTP 等协议。
  - 用户user:某些方案访问资源时候需要指定用户名，才有权限获取资源。
  - 密码password:用户名后面可能需要密码进行验证，用户名与密码直接使用“:”冒号分隔连接。
  - 主机host:资源宿主服务器的主机名或者 IP 地址（点分十进制）。
  - 端口port:资源宿主服务器正在监听的端口号，很多方案都有默认的端口号，而无需我们自己填写，比如 HTTP 默认使用 80 端口， HTTPS 默认使用443 端口。 端口不是一个 URL 必须的部分，如果省略端口部分，将采用默认端口。
  - 路径path:服务器本地资源的路径，类似于电脑中的文件路径一样，使用“/”将路径与端口隔离。 从域名后的第一个“/”开始到最后一个“/”为止，虚拟目录也不是一个 URL 必须的部分，在路径之后是需要一个文件名，这就是 URL 指定的资源。 文件名部分也不是一个 URL 必须的部分，如果省略该部分，则使用默认的文件名
  - 参数params:某些方案会使用这个组件来输入参数，可以拥有多个参数，使用“;”符号与路径分隔开。
  - 查询query :某些方案会使用这个组件传递参数以激活应用程序，查询组件的内容没有通用的格式，用“?”字符与其他组件分隔开.
  - 片段frag:一小片或者一部分资源的名字，引用对象时，不会将片段组件内容传输给服务器，这个字段是在客户端内部使用的，通过“#”字符与其他组件分隔开。


```
//HTTP应答报文
<version> <status> <reason-phrase> //起始行
<headers> //首部
<entity-body> //数据主体


//HTTP请求报文
<method> <request-URL> <version> //起始行
<headers> //首部
<entity-body> //数据主体
```

#### 大致流程
- 创建一个连接结构。
- 连接到域名的服务器中（一般建议打开 DNS），端口号为方案对应的默认端口号。
-  发送 HTTP 请求报文。
- 等待服务器端的应答，并且接收数据。

### MQTT协议(消息队列遥测传输协议)
- 是一种基于发布/订阅（Publish/Subscribe）模式的轻量级通讯协议
- 在物联网开发中，MQTT不是唯一的选择，与MQTT互相竞争的协议有XMPP和CoAP协议等
- 属于应用层,只要支持TCP/IP协议,都可以使用MQTT
- 可以一对多的的消息发布,具有3种身份,发布者,服务器和订阅者.发布者也可以是订阅者

- 通信模型
![mqtt](.\img\mqtt.jpg)

- 主题
- 服务质量
  - QoS0,只发送一次消息,无论接收者有没有收到,不需要接收者应答
  - QoS1,最少要送达一次,可重复,包含报文的标识符,需要接收者应答
  - QoS2,消息的丢失和重复都不可接受, 常用于支付
- 报文有三个部分组成
  - 固定报文头 
  - 可变报文头
  - 负荷 
- 固定报头（fixed header）一定会包含的头部
  - 第一字节:包含消息类型（Message Type）和QoS级别等标志位。
  - 消息类型如图
  ![mqtt_head](.\img\mqtt_head.jpg)
  - 标志位
    - 除了PUBLISH类型报文以外,其他报文的标志位均为系统保留,PUBLISH 报文的第一字节bit3 是控制报文的重复分发标志（DUP）,bit1-bit2 是服务质量等级,bit0 是PUBLISH 报文的保留标志,用于标识PUBLISH 是否保留，
  -  第二字节:剩余长度字段单个字节最大值为二进制0b0111 1111，16进制0x7F。也就是说，单个字节可以描述的最大长度是127字节。为什么不是256字节呢？因为MQTT协议规定，单个字节第八位（最高位）若为1，则表示后续还有字节存在，第八位起“延续位”的作用。由于MQTT协议最多只允许使用四个字节表示剩余长度，并且最后一字节最大值只能是0x7F不能是0xFF，所以能发送的最大消息长度是256MB，而不是512MB
- 可变报头（variable header）
- 有很多种,每一种都不一样
- 如CONNECT报文
![mqtt_connect](.\img\mqtt_connect.jpg)
- CONNACK报文
![mqtt_connack](.\img\mqtt_connack.jpg)

- 有效荷载（数据区域 payload）
  - 当MQTT发送的消息类型是CONNECT（连接）、PUBLISH（发布）、SUBSCRIBE（订阅）、SUBACK（订阅确认）、UNSUBSCRIBE（取消订阅）时，则会带有负荷。
  - 遗愿标志（Will Flag）
    - 如果设备无响应,则服务器会代替设备去通知使用者
  - 连接保活心跳机制（Keep Alive Timer）
- 一般都是MQTT+JOSN配合

### UDP(User Datagram Protocol)
- 无连接,不可靠,传输层协议
- 接收错误直接扔掉,不反馈
- 数据过长使用IP层分片
- 基于UDP的协议

| 端口号| 协议 | 说明|
| ------ | ---- | ------------------ |
| 53     | DNS  | 域名服务器         |
| 69     | TFTP | 简单文件传输协议   |
| 123    | NTP  | 同步网络时间的协议 |
| 161    | SNMP | 简单的网络管理协议 |


- 协议头部

| 16BIT                                                        | 16BIT                                                |
| ------------------------------------------------------------ | ---------------------------------------------------- |
| **源端口号**需要对方回信时选用，不需要时全部置0              | **目标端口号** 在终点交付报文的时候需要用到          |
| **总长度** UDP的数据报的长度（包括首部和数据）其最小值为8（只有首部） | **校验和** 检测UDP数据报在传输中是否有错，有错则丢弃 |
| 数据区域                                                     |                                                      |

- UDP校验
  - 在计算校验和的时，需要在UDP数据报之前增加12字节的伪首部，伪首部并不是UDP真正的首部,用于校验计算
- 伪头部
| 4字节    | 4字节      | 1字节 | 1字节 | 2字节   |
| -------- | ---------- | ----- | ----- | ------- |
| 源IP地址 | 目的IP地址 | 0     | 17    | UDP长度 |

| 12字节 | 2字节  | 2字节    | 2字节 | 2字节  |
| ------ | ------ | -------- | ----- | ------ |
| 伪头部 | 源端口 | 目标端口 | 长度  | 校验和 |

- 发送方计算方法
  - 二进制反码求和再取反,把首部和数据部分一起校验,如果字节数为奇数,则在数据末尾加一个全0字节
- 接收方计算方法
  - 收到UDP数据报后,加上伪首部(如果奇数也要补字节).然后计算二进制反码的和,无差错结果为1
- 注意
  - 虽然可能会加字节,但是它和伪首部一样都是不发送的,只是为了计算.
  - 计算的时候是以16位作为最小单位来计算的

### TCP(TransmissionControl Protocol)
- 面向连接,可靠,传输层协议
- 数据大时重装数据,因为报文到达的时间不一样,组装完毕才ACK,并且上传到应用层
- MAC地址:区分网卡   
- IP地址:区分主机  端口号: 区分线程
- 基于TCP的协议

| 端口号 | 协议   | 说明                        |
| ------ | ------ | --------------------------- |
| 20/21  | FTP    | 文件传输协议                |
| 23     | Telnet | 终端远程登录,可控制远程主机 |
| 25     | SMTP   | 简单邮件传输协议            |
| 80     | HTTP   | 超文本传输协议              |
| 110    | POP3   | 邮局协议版本3               |

- 协议头部
  - RUG:为1,则紧急指针字段有效
  - ACK:为1,则确认序号有效,代表应答报文
  - PSH:为1.表示尽快将报文段送给应用层
  - RST:复位标志,重新建立连接
  - SYN:同步标志,4次握手,用于发起连接
  - FIN:结束标志,3次挥手,用于断开连接
| 16BIT                                                        | 16BIT      |
| ------------------------------------------------------------ | ---------- |
| 源端口号                                                     | 目标端口号 |
| 序号                                                         |            |
| 确认序号                                                     |            |
| \| 首部长度 \| 保留 \| URG \| ACK \| PSH \| RST \| SYN \| FIN \| \|   4    \|  6  \|               6              \| | 窗口大小   |
| 校验和                                                       | 紧急指针   |
| 选项(可选,不定长)                                            |            |
| 数据                                                         |            |



- 建立连接过程
![tcp_1](.\img\tcp_1.jpg)


- 断开连接过程
![tcp_2](.\img\tcp_2.jpg)

- 窗口概念
  -  rcv_nxt:期望下一个接收到的序号
  -  rcv_wnd:接收窗口大小
  -  rcv_ann_wnd:告诉发送方要修改的大小
  -  rcv_ann_right_edge:窗口的右边界
  ![tcp_window](.\img\tcp_window.jpg)





- 糊涂窗口
- 保活机制
- 拥塞控制
  - 慢开始,拥塞避免
- 流量控制
- 超时重传

### ICMP(Internet Control Message Protocol)
- 网络层协议,主要用在网路层报错
- 协议头部

| 8BIT               | 8BIT | 16BIT  |
| ------------------ | ---- | ------ |
| 类型               | 代码 | 校验和 |
| 不同类型有不同内容 |      |        |

- 类型:第一类是取值为1~127的差错报文，第2类是取值128以上的信息报文
- 代码:该类型下的不同情况
- 校验和: 将数据以字（16位）为单位累加到一个双字中，如果数据长度为奇数，最后一个字节将被扩展到字，累加的结果是一个双字，最后将这个双字的高16位和低16位相加后取反，便得到了校验和 (头部+数据)

```C
USHORT checksum(USHORT *buffer,int size)
{
    unsigned long cksum=0;
    //将数据以字为单位累加到CKSUM中
    while(size>1)
    {
        cksum+=*buffer++;
        size-=sizeof(USHORT);
    }
    //如果为奇数，将最后一个字节扩展到双字，再累加到cksum中
    if(size)
    {
        cksum+=*(UCHAR *)buffer;
    }
    //将cksum的高16位和低16位相加，取反后得到校验和
    cksum=(cksum>>16)+(cksum&0xffff);
    cksum+=(cksum>>16);
    return (USHORT)(~cksum);
}
```

![icmp_type](.\img\icmp_type.jpg)
![icmp_code](.\img\icmp_code.jpg)

- 源站抑制:数据发送太快接收不过来
- 重定向:用于初始化的主机,路由器应答,更短的路径
- 超时:如TTL到这里减为零,则会应答超时报文给源主机,或者是分片组装超时
- 参数错误:IP数据报的参数错误

### IP(Internet Protocol)
- 网络层协议
- 广播IP地址 255.255.255.255
- 组播IP地址: 224.0.0.0 ~ 239.255.255.255
- 环回地址:  127.1.1.1 (协议栈遇到此地址,调用发送函数发回给自己)
- 局域网:链路层是相通的
- 互联网就是由无数个局域网，通过广域网线路汇聚互联起来，就形成了互联网。
  - 家里---->营业厅------>世界
- 协议头部
  - 版本:IPv4 IPv6
  - 首部长度:** 区间为[20,60]   单位为字节
  - 服务类型:
  - 数据报总长度 : 一般如果不要分片,则IP层最大字节设置为1480字节
  - 以太网头(14字节)+IP头(20字节)+TCP头(20字节)+数据(1460字节)
  - 标识:用于判断是否同一个IP报文
  - 标志位: 第一位:保留 第二位:为1表示不分片  第三位: 为1表示不是最后一个分片
  - 分片偏移量:8字节为单位,重装需要用到
  - 生存时间:每经过一个路由器或者主机会减1,减到0会发送ICMP报文
  - 上层协议:要递交的协议,6表示TCP协议,17表示UDP协议
  - 首部校验和:ip头(共20个字节)按照每16个bit作为一个值依次进行相加,将计算结果的进位加到低16位上,将结果取反
| 4BIT       | 4BIT       | 8BIT              | 8BIT       | 8BIT |
| ---------- | ---------- | ----------------- | ---------- | ---- |
| 版本       | 首部长度   | 服务类型TOS       | 数据报长度 |      |
| 标识       | 标志(3BIT) | 分片偏移量(13BIT) |            |      |
| 生存时间   | 上层协议   | 首部校验和        |            |      |
| 源IP地址   |            |                   |            |      |
| 目标IP地址 |            |                   |            |      |
| 选项(可选) |            |                   |            |      |
| 数据       |            |                   |            |      |



### DHCP(动态主机配置协议)
- 应用层协议,基于UDP
- 请求DHCP服务器分配一个临时IP地址作使用
- 租约表:客户端需要租用IP地址的时间
- 步骤
  - 首先客户端不知道自己的IP地址,发送DHCP Discover包,源IP地址0-0-0-0,目的IP地址FF-FF-FF-FF,所有主机都能收到,但只有DHCP服务器会应答,如果没回应,则按照 当前时间*2 重新发,如1 2 4 8 16
  - DHCP服务器先查询空闲可用的IP地址,找最前面可用的,发送DHCP offer包,包含IP地址,租期等
  - 客户端再回应DHCP request包作确认
  - 最后客户端会收到DHCP ack,此时IP地址租用成功
  - 客户端会发送ARP请求,看看该网络下有没有其他主机用了这个地址,如果用了,则发DHCP decline结束使用此地址,然后重复1的步骤.



### DNS(域名解析协议)
- 将域名转换成IP地址
- 基于UDP实现
- 域名的层次结构

![dns](.\img\dns.jpg)

- 查询过程
  - 输入域名后, 先查找自己主机对应的域名服务器，域名服务器先查找自己的数据库中的数据. 
  - 如果没有， 就向上级域名服务器进行查找， 依次类推 
  - 最多回溯到根域名服务器, 肯定能找到这个域名的IP地址 
  - 域名服务器自身也会进行一些缓存， 把曾经访问过的域名和对应的IP地址缓存起来, 可以加速查找过程 

###  ARP(地址解析协议)
- ARP缓存表,IP地址和MAC地址建立映射,生存时间5分钟,请求等待是5秒,有静态表和动态表
- MAC地址: 6字节
- 协议头部

| 2BYTE    | 2BYTE        | 1BYTE       | 1BYTE      | 2BYTE    | 6BYTE     | 4BYTE    | 6BYTE       | 4BYTE      |
| -------- | ------------ | ----------- | ---------- | -------- | --------- | -------- | ----------- | ---------- |
| 硬件类型 | 上层协议类型 | MAC地址长度 | IP地址长度 | 操作类型 | 源MAC地址 | 源IP地址 | 目标Mac地址 | 目的IP地址 |
| ARP报头  |              |             |            |          |           |          |             |            |

- 硬件类型:1表示为以太网
- 上层协议类型:0x0800表示IP地址
- MAC地址长度:6
- IP地址长度: 4
- 操作类型:一般只用前面两个
  - ARP 请求，其值为 1
  - ARP 应答，其值为 2
  - RARP 请求，其值为 3
  - RARP 应答，其值为 4
- 注意:在发送 ARP 请求包的时候，以太网首部的目标 MAC 地址是 FF-FF-FF-FF-FFFF，而 ARP 首部目标 MAC 地址为 00-00-00-00-00-00-00

### NAT(网络地址转换协议)
- 因为IPv4地址不够用,所以用一个NAT转换器,把公网的地址转换成私有地址
- 怎么区分私有地址呢,唯一的方法是同个端口号,每一个连接的主机被看成一个线程,这样最大有65535个
- 增强了内网的安全性

### 链路层(以太网)
- 以太网头部
  - 前同步码:调整时钟频率
  - 帧开始符:表明下一字节是以太网帧的开始
  - 类型:表示要传输的数据到哪个协议,如IP 协议(0x0800),ARP 协议(0x0806)
  - CRC:模2除法
    - 首先,接收方和发送方都要有相同的除数(多项式),如G(X)=X^4+X^3+1 ,得出除数为11001(5位),然后数据后面要补上N-1个零,这里是4个0
    -  然后进行相除,直到比除数少1位为止,此时的余数加到数据后面就可以,如果前面有0,则补齐到N-1位
    - 接收到数据后,把数据(包括发送方填充的余数)进行同样的操作,结果为零则校验正确

| 7BYTE    | 1BYTE    | 6BYTE       | 6BYTE     | 2BYTE | 46~1500BYTE | 4BYTE |
| -------- | -------- | ----------- | --------- | ----- | ----------- | ----- |
| 前同步码 | 帧开始符 | 目的MAC地址 | 源MAC地址 | 类型  | 数据        | CRC   |



- CSMA/CD(载波监听多点接入/碰撞检测)
  - 多点接入:一条总线上有多台主机接入
  - 载波监听:检测总线上有没有人正在发送数据,防止碰撞,确定没有才发出
  - 碰撞检测:边发送边监听,多个主机发数据的话总线上的电压因叠加会变大,此时主机会认为总线上发生了碰撞
  - 因为距离问题,1KM的电缆传输时间是5us,所以最大时延知道碰撞的时间是2x, x是A到B的距离
  - 以前是总线,现在改成星型拓扑结构,用集线器(hub)替代,但是协议上还是CSMA/CD